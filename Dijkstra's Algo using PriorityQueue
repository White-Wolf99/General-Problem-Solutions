// User Function Template
class Solution {
  public:

    //Greedy shortest-path algorithm = Dijkstra's Algorithm

    vector<int> dijkstra(int V, vector<vector<int>> &edges, int src) {
        // Code here
        unordered_map<int, vector<pair<int, int>>> adj;
        
        for(auto &E: edges){            //Iterate thru each vector in the edges
            int u = E[0], v = E[1], w = E[2];
            adj[u].push_back({v, w});
            adj[v].push_back({u, w});
        }
        
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        vector<int> result(V, INT_MAX);
        
        result[src] = 0;
        pq.push({0, src});
        while(!pq.empty()){
            
            int dist = pq.top().first;    //distance of the top node (0 at first)
            int Node = pq.top().second;   //the Node
            pq.pop();                       //Pop the top pair 
            
            for(auto &v: adj[Node]){        //Go through the adj list of the node
                int adjNode = v.first;         //Store the adjacent node
                int weight = v.second;          //Store the weight to the adjacent node from the node 
                
                if(dist + weight < result[adjNode]){   //Add the distance + the weight to the adj node
                    result[adjNode] = dist + weight;   // Assign if that is lower than the existing value of that particular node
                    pq.push({dist+weight, adjNode});  //Only push to the pq if the pair is updated
                }
                
            }
        }
        return result;
    }
};





